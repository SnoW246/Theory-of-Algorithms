#lang racket

; Module: Theory of Algorithms
; Problem Sheet: Racket
; Author: Adrian Golias

; The following exercises are related to the Racket programming language [3].

; References: [1] Project Euler. Project euler.
;             [2] Brian Harvey and Matt Wright.
;                 Simply scheme: Introducing computer science.
;             [3] PLT Inc. Racket – A programmable programming language.

; Q1. Re-write the following expressions in Racket and evaluate them
;     using a Racket interpreter/compiler.

; Q1.(a) (3 × (5 + (10 ÷ 5)))
'Q1.a: (*(+(/ 10 5) 5) 3)
; Q1.(b) (2 + 3 + 4 + 5)
'Q1.b: (+ 2 3 4 5)
; Q1.(c) (1 + (5 + (2 + (10 ÷ 3))))
'Q1.c: (+ 1 5 2 (/ 10 3))
; Q1.(d) (1 + (5 + (2 + (10 ÷ 3.0))))
'Q1.d: (+ 1 5 2 (/ 10 3.0))
; Q1.(e) (3 + 5) × (10 ÷ 2)
'Q1.e: (* (+ 3 5) (/ 10 2))
; Q1.(f) (3 + 5) × (10 ÷ 2) + (1 + (5 + (2 + (10 ÷ 3))))
'Q1.f: (+ (* (+ 3 5) (/ 10 2)) (+ 1 5 2 (/ 10 3)))

; Q2. Define a procedure discount that takes two arguments:
;     An item’s initial price and a percentage discount [2].
;     It should return the new price:

;     > (discount 10 5)
;     9.50
;     > (discount 29.90 50)
;     14.95

(define (discount x y)
  (- x (* x (/ y 100.0))))

'Q2:
(discount 10 5)
(discount 29.90 50)

; Q3. Define a function grcomdiv that takes two integers and
;     returns their greatest common divisor.
;     > (grcomdiv 10 15)
;     5
;     > (grcomdiv 64 30)
;     2

; https://rosettacode.org/wiki/Greatest_common_divisor
(define (grcomdiv x y )
  (if (= y 0)
      x
      (grcomdiv y (modulo x y))))

'Q3:
(grcomdiv 10 15)
(grcomdiv 64 30)

; Q4. Write a function called appearances that returns the
;     number of times its first argument appears as a
;     member of its second argument [2].

(define (appearances x y)
  (if (null? y)
      0
      (if (equal? x (car y))
          (+ 1 (appearances x (cdr y))
          (appearances x (cdr y)))))

'Q4: 
(appearances 10 2)

; Q5. Write a procedure inter that takes two lists as arguments.
;     It should return a list containing every element that
;     appears in both lists, exactly once.



; Q6. Write a procedure noatoms that takes a list and returns
;     the number of atoms it contains.



; Q7. Here is a Racket procedure that never finishes its
;     job when n is not 0:

;     (define (forever n)
;       (if (= n 0)
;            1
;            (+ 1 (forever n))))

;     Explain why it doesn’t give any result[2].



; Q8. Write a function called range that takes an integer n
;     and returns a list containing the atoms 1, 2, 3, . . . , n.



; Q9. Write a function called reversel that takes a list
;     and returns it reversed.



; Q10. If we list all the natural numbers below 10 that are
;      multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these
;      multiples is 23. Write a procedure to find the sum of all
;      the multiples of 3 or 5 below 1000 [1].



; Q11. Write a procedure called flatten that takes as its argument
;      a list, possibly including sublists, but whose ultimate
;      building blocks are atoms. It should return a sentence
;      containing all the atoms of the list, in the order in which
;      they appear in the original:

;      > (flatten '(((a b) c (d e)) (f g) ((((h))) (i j) k)))
;      (a b c d e f g h i j k)



; Q12. Each new term in the Fibonacci sequence is generated by
;      adding the previous two terms. By starting with 1 and 2,
;      the first 10 terms will be:

;      1, 2, 3, 5, 8, 13, 21, 34, 55, 89

;      By considering the terms in the Fibonacci sequence whose
;      values do not exceed four million, find the sum of the
;      even-valued terms [1].



; Q13. Write a procedure to-binary that takes a decimal interger
;      and converts it into a list of 0’s and 1’s representing
;      the number in binary form. The least significant bit
;      should be on the right of the list.

;      > (to-binary 9)
;      1001
;      > (to-binary 23)
;      10111



; Q14. Write a function select that takes two elements, a list and
;      a position in the list, and return the element of the list
;      in that position.

;      > (select (list 1 2 3 4 5) 1)
;      2

(define (select l x)
  (if (= x 0)
      (car l)
      (select (cdr l) (- x l))))

;(select (list 1 2 3 4 5) 1)


; Q15. Write a function perms that takes a list as its only argument,
;      and returns a list containing all permutations of that list.

